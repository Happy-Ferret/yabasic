#!/usr/bin/ruby

require 'pp'
require 'fileutils'
include FileUtils
require 'erb'
require 'rake/testtask'
require 'matrix'
require_relative '../windows/utils.rb'

yab_app_dir = '/usr/local/share/applications/yabasic'
vs=Hash.new
vs['configure.ac']=File.new('lang/configure.ac').read.match(/AC_INIT\(\[yabasic\],\s+\[(\d\.\d+\.\d+)\]\)/)[1]

desc 'Check git'
task :git do 
  sh "git diff --exit-code --quiet" do |ok,res|
    if !ok
      sh "git status"
      warn "Uncommited local changes, please fix with 'git add' etc."
    end
  end
end

desc 'Put version into documentation'
file 'doc/yabasic.xml' => 'doc/yabasic.xml.erb' do
  version_short = vs['configure.ac'].gsub(/\.\d+$/,"")
  File.open('doc/yabasic.xml','w') do |file|
    file.write ERB.new(File.read('doc/yabasic.xml.erb')).result(binding)
  end
end

desc 'Create html doc from xml'
file 'lang/yabasic.htm' => 'doc/yabasic.xml' do
  ENV['SGML_CATALOG_FILES']='/etc/xml/catalog'
  sh 'xsltproc doc/mystyle.xsl doc/yabasic.xml >lang/yabasic.htm'
end

desc 'Create man page'
file 'lang/yabasic.1' => ['lang/yabasic.htm','doc/yabasic.1.erb'] do
  sh 'w3m -dump -o display_charset=ascii,cols=74 lang/yabasic.htm >/tmp/y.utf8'
  ascii = File.new('/tmp/y.utf8').read.lines.map {|x| " " + x}.join
  open('lang/yabasic.1','w') {|f| f.write ERB.new(File.new('doc/yabasic.1.erb').read).result(binding)}
end

desc 'Create configure'
file 'lang/configure' => 'lang/configure.ac' do
  cd ('lang') { sh 'autoconf' }
end

desc 'Create Makefile.in'
file 'lang/Makefile.in' => 'lang/Makefile.am' do
  cd ('lang') { sh 'automake' }
end

desc 'Create Makefile'
file 'lang/Makefile' => ['lang/Makefile.in','lang/configure'] do
  cd ('lang') {
    sh 'configure'
    sh 'config.status'
  }
end

desc 'Run make'
task :make => 'lang/yabasic.1' do
  cd ('lang') { sh 'make' }
end

desc 'Run tests'
task :tests => :make do
  run_tests './lang/tests', '../yabasic'
end

desc 'Collect Versions'
task :versions => [:git,'lang/yabasic.htm',:tests,'lang/Makefile','lang/configure'] do
  vs['yabasic']=%x( lang/yabasic -v 2>&1 ).match(/yabasic (\d\.\d+\.\d+)/ )[1]
  vs['yabasic.htm']=File.new('lang/yabasic.htm').read.match(/This document applies to version\s+(\d\.\d+)/)[1]
  vs['NEWS']=File.new('lang/NEWS').read.match(/Version\s+(\d\.\d+.\d+)/)[1]
  vs['ChangeLog']=File.new('lang/ChangeLog').read.match(/Version\s+(\d\.\d+.\d+)/)[1]
  pp vs
  fail "Mismatch between versions of 'yabasic' and 'yabasic.htm'" if (vs['yabasic'].to_f-vs['yabasic.htm'].to_f).abs >= 0.01
  fail "Mismatch between versions of 'yabasic' and 'configure.ac'" if vs['yabasic'] != vs['configure.ac']
  fail "Mismatch between versions of 'NEWS' and 'configure.ac'" if vs['NEWS'] != vs['configure.ac']
  fail "Mismatch between versions of 'NEWS' and 'ChangeLog'" if vs['NEWS'] != vs['ChangeLog']
end

desc 'Create directory to collect products'
task :products_dir => :versions do
  mkdir '../products' unless Dir.exists?('../products')
end

desc 'Create tar with sources'
task :sources => :products_dir do
  cd 'lang' do
    sh 'make dist-gzip'
    mv "yabasic-#{vs['yabasic']}.tar.gz", '../../products'
  end
end
  
desc 'Create rpm'
task :rpm => :products_dir do
  cd "lang" do
    sh 'make install DESTDIR=pkg'
    mkdir_p "pkg/#{yab_app_dir}"
    %w( demo.yab yabasic.htm ).each do |file|
      cp file, "pkg/#{yab_app_dir}"
    end
    %w( rpm deb ).each do |fmt|
      sh "fpm -f -s dir -t #{fmt} -n yabasic -v #{vs['yabasic']} -C pkg"
    end
    mv "yabasic-#{vs['yabasic']}-1.x86_64.rpm",'../../products'
    mv "yabasic_#{vs['yabasic']}_amd64.deb",'../../products'
  end
end

desc 'Cleanup, sync and show products'
task :default => [:rpm, :sources] do
  prod_globs = %w( yabasic*.x86_64.rpm yabasic*amd64.deb yabasic*.tar.gz )
  prod_globs.each { |glob| cleanup "../products/#{glob}" }
  sync_dest = '/work/yabasic/products'
  if File.directory?(sync_dest)
    Dir['../products/*'].each do |p|
      cp p, sync_dest
    end
    prod_globs.each { |glob| cleanup sync_dest+"/"+glob }
    cp 'lang/yabasic.htm', sync_dest
    sh "ls -l #{sync_dest}"
  else
    puts "Sync destination #{sync_dest} not present !"
  end
end

